@Inject
class A {
  val b: B
    field = b
    get

  val e: E
    field = e
    get

  @Deprecated(message = "This synthesized declaration should not be used directly", level = DeprecationLevel.HIDDEN)
  class MetroFactory : Factory<A> {
    private /* final field */ val b: Provider<B> = b
    private /* final field */ val e: Provider<E> = e
    companion object Companion {
      private constructor() /* primary */ {
        super/*Any*/()
        /* <init>() */

      }

      fun create(b: Provider<B>, e: Provider<E>): Factory<A> {
        return MetroFactory(b = b, e = e)
      }

      fun newInstance(b: B, e: E): A {
        return A(b = b, e = e)
      }

    }

    private constructor(b: Provider<B>, e: Provider<E>) /* primary */ {
      super/*Any*/()
      /* <init>() */

    }

    override operator fun invoke(): A {
      return Companion.newInstance(b = <this>.#b.invoke(), e = <this>.#e.invoke())
    }

    fun mirrorFunction(b: B, e: E): A {
      return error(message = "Never called")
    }

  }

  constructor(b: B, e: E) /* primary */ {
    super/*Any*/()
    /* <init>() */

  }

}

@Inject
class B {
  val c: C
    field = c
    get

  @Deprecated(message = "This synthesized declaration should not be used directly", level = DeprecationLevel.HIDDEN)
  class MetroFactory : Factory<B> {
    private /* final field */ val c: Provider<C> = c
    companion object Companion {
      private constructor() /* primary */ {
        super/*Any*/()
        /* <init>() */

      }

      fun create(c: Provider<C>): Factory<B> {
        return MetroFactory(c = c)
      }

      fun newInstance(c: C): B {
        return B(c = c)
      }

    }

    private constructor(c: Provider<C>) /* primary */ {
      super/*Any*/()
      /* <init>() */

    }

    override operator fun invoke(): B {
      return Companion.newInstance(c = <this>.#c.invoke())
    }

    fun mirrorFunction(c: C): B {
      return error(message = "Never called")
    }

  }

  constructor(c: C) /* primary */ {
    super/*Any*/()
    /* <init>() */

  }

}

@Suppress(names = ["MEMBERS_INJECT_WARNING"])
@Inject
class C {
  val aProvider: Provider<A>
    field = aProvider
    get

  lateinit var aLazy: Lazy<A>
    get
    set

  lateinit var aLazyProvider: Provider<Lazy<A>>
    get
    set

  @Deprecated(message = "This synthesized declaration should not be used directly", level = DeprecationLevel.HIDDEN)
  class MetroFactory : Factory<C> {
    private /* final field */ val aProvider: Provider<A> = aProvider
    private /* final field */ val aLazy: Provider<A> = aLazy
    private /* final field */ val aLazyProvider: Provider<A> = aLazyProvider
    companion object Companion {
      private constructor() /* primary */ {
        super/*Any*/()
        /* <init>() */

      }

      fun create(aProvider: Provider<A>, aLazy: Provider<A>, aLazyProvider: Provider<A>): Factory<C> {
        return MetroFactory(aProvider = aProvider, aLazy = aLazy, aLazyProvider = aLazyProvider)
      }

      fun newInstance(aProvider: Provider<A>): C {
        return C(aProvider = aProvider)
      }

    }

    private constructor(aProvider: Provider<A>, aLazy: Provider<A>, aLazyProvider: Provider<A>) /* primary */ {
      super/*Any*/()
      /* <init>() */

    }

    override operator fun invoke(): C {
      val tmp_0: C = Companion.newInstance(aProvider = <this>.#aProvider)
      Companion.injectALazy(instance = tmp_0, aLazy = Companion.lazy<Provider<A>, A>(provider = <this>.#aLazy))
      Companion.injectALazyProvider(instance = tmp_0, aLazyProvider = Companion.create<A>(provider = <this>.#aLazyProvider))
      return tmp_0
    }

    fun mirrorFunction(aProvider: Provider<A>): C {
      return error(message = "Never called")
    }

  }

  @Deprecated(message = "This synthesized declaration should not be used directly", level = DeprecationLevel.HIDDEN)
  class MetroMembersInjector : MembersInjector<C> {
    private /* final field */ val aLazy: Provider<A> = aLazy
    private /* final field */ val aLazyProvider: Provider<A> = aLazyProvider
    companion object Companion {
      private constructor() /* primary */ {
        super/*Any*/()
        /* <init>() */

      }

      fun create(aLazy: Provider<A>, aLazyProvider: Provider<A>): MembersInjector<C> {
        return MetroMembersInjector(aLazy = aLazy, aLazyProvider = aLazyProvider)
      }

      fun injectALazy(@Assisted instance: C, aLazy: Lazy<A>) {
        return instance.#aLazy = aLazy
      }

      fun injectALazyProvider(@Assisted instance: C, aLazyProvider: Provider<Lazy<A>>) {
        return instance.#aLazyProvider = aLazyProvider
      }

    }

    private constructor(aLazy: Provider<A>, aLazyProvider: Provider<A>) /* primary */ {
      super/*Any*/()
      /* <init>() */

    }

    override fun injectMembers(instance: C) {
      Companion.injectALazy(instance = instance, aLazy = Companion.lazy<Provider<A>, A>(provider = <this>.#aLazy))
      Companion.injectALazyProvider(instance = instance, aLazyProvider = Companion.create<A>(provider = <this>.#aLazyProvider))
    }

  }

  constructor(aProvider: Provider<A>) /* primary */ {
    super/*Any*/()
    /* <init>() */

  }

}

@Inject
class D {
  val b: B
    field = b
    get

  @Deprecated(message = "This synthesized declaration should not be used directly", level = DeprecationLevel.HIDDEN)
  class MetroFactory : Factory<D> {
    private /* final field */ val b: Provider<B> = b
    companion object Companion {
      private constructor() /* primary */ {
        super/*Any*/()
        /* <init>() */

      }

      fun create(b: Provider<B>): Factory<D> {
        return MetroFactory(b = b)
      }

      fun newInstance(b: B): D {
        return D(b = b)
      }

    }

    private constructor(b: Provider<B>) /* primary */ {
      super/*Any*/()
      /* <init>() */

    }

    override operator fun invoke(): D {
      return Companion.newInstance(b = <this>.#b.invoke())
    }

    fun mirrorFunction(b: B): D {
      return error(message = "Never called")
    }

  }

  constructor(b: B) /* primary */ {
    super/*Any*/()
    /* <init>() */

  }

}

@Inject
class E {
  val d: D
    field = d
    get

  @Deprecated(message = "This synthesized declaration should not be used directly", level = DeprecationLevel.HIDDEN)
  class MetroFactory : Factory<E> {
    private /* final field */ val d: Provider<D> = d
    companion object Companion {
      private constructor() /* primary */ {
        super/*Any*/()
        /* <init>() */

      }

      fun create(d: Provider<D>): Factory<E> {
        return MetroFactory(d = d)
      }

      fun newInstance(d: D): E {
        return E(d = d)
      }

    }

    private constructor(d: Provider<D>) /* primary */ {
      super/*Any*/()
      /* <init>() */

    }

    override operator fun invoke(): E {
      return Companion.newInstance(d = <this>.#d.invoke())
    }

    fun mirrorFunction(d: D): E {
      return error(message = "Never called")
    }

  }

  constructor(d: D) /* primary */ {
    super/*Any*/()
    /* <init>() */

  }

}

@GraphExtension
interface ChildCycleGraph {
  @Factory
  fun interface Factory {
    abstract fun create(): ChildCycleGraph

  }

  abstract val a: A
    abstract get

  abstract val obj: Any
    abstract get

}

@DependencyGraph
interface CycleGraph {
  @Deprecated(message = "This synthesized declaration should not be used directly", level = DeprecationLevel.HIDDEN)
  @MetroImplMarker
  class Impl : CycleGraph {
    private val thisGraphInstance: CycleGraph
      field = <this>

    private val cycleGraphProvider: Provider<CycleGraph>
      field = Companion.invoke<CycleGraph>(value = <this>.#thisGraphInstance)

    private val cProvider: Provider<C>
      field = DelegateFactory<C>()

    private val provideObjectWithCycleProvider: Provider<Any>
      field = DelegateFactory<Any>()

    private val bProvider: Provider<B>
      field = Companion.create(c = <this>.#cProvider)

    private val aProvider: Provider<A>
      field = Companion.create(b = <this>.#bProvider, e = Companion.create(d = Companion.create(b = <this>.#bProvider)))

    @DependencyGraph
    inner class ChildCycleGraphImpl : ChildCycleGraph {
      private val cProvider: Provider<C>
        field = DelegateFactory<C>()

      private val provideObjectWithCycleProvider: Provider<Any>
        field = DelegateFactory<Any>()

      private val bProvider: Provider<B>
        field = Companion.create(c = <this>.#cProvider)

      private val aProvider: Provider<A>
        field = Companion.create(b = <this>.#bProvider, e = Companion.create(d = Companion.create(b = <this>.#bProvider)))

      private class FactoryImpl : Factory {
        private /* final field */ val parentInstance: Impl = parentInstance
        constructor(parentInstance: Impl) /* primary */ {
          super/*Any*/()
          /* <init>() */

        }

        override fun create(): ChildCycleGraph {
          return <this>.#parentInstance.ChildCycleGraphImpl()
        }

      }

      constructor() /* primary */ {
        super/*Any*/()
        /* <init>() */

        Companion.setDelegate<C>(delegateFactory = <this>.#cProvider, delegate = Companion.create(aProvider = <this>.#aProvider, aLazy = <this>.#aProvider, aLazyProvider = <this>.#aProvider))
        Companion.setDelegate<Any>(delegateFactory = <this>.#provideObjectWithCycleProvider, delegate = Companion.create(instance = <this>, obj = <this>.#provideObjectWithCycleProvider))
      }

      override val a: A
        override get(): A {
          return <this>.#aProvider.invoke()
        }

      override val obj: Any
        override get(): Any {
          return <this>.#provideObjectWithCycleProvider.invoke()
        }

    }

    private constructor() /* primary */ {
      super/*Any*/()
      /* <init>() */

      Companion.setDelegate<C>(delegateFactory = <this>.#cProvider, delegate = Companion.create(aProvider = <this>.#aProvider, aLazy = <this>.#aProvider, aLazyProvider = <this>.#aProvider))
      Companion.setDelegate<Any>(delegateFactory = <this>.#provideObjectWithCycleProvider, delegate = Companion.create(instance = <this>.#thisGraphInstance, obj = <this>.#provideObjectWithCycleProvider))
    }

    override fun a(): A {
      return <this>.#aProvider.invoke()
    }

    override fun c(): C {
      return <this>.#cProvider.invoke()
    }

    override fun childCycleGraph(): Factory {
      return FactoryImpl(parentInstance = <this>.#cycleGraphProvider.invoke())
    }

    override val objWithCycle: Any
      override get(): Any {
        return <this>.#provideObjectWithCycleProvider.invoke()
      }

  }

  companion object Companion {
    private constructor() /* primary */ {
      super/*Any*/()
      /* <init>() */

    }

    @GraphFactoryInvokeFunctionMarker
    operator fun invoke(): CycleGraph {
      return Impl()
    }

  }

  @Deprecated(message = "This synthesized declaration should not be used directly", level = DeprecationLevel.HIDDEN)
  @CallableMetadata(callableName = "provideObjectWithCycle", propertyName = "", startOffset = 497, endOffset = 594)
  class ProvideObjectWithCycleMetroFactory : Factory<Any> {
    private /* final field */ val instance: CycleGraph = instance
    private /* final field */ val obj: Provider<Any> = obj
    companion object Companion {
      private constructor() /* primary */ {
        super/*Any*/()
        /* <init>() */

      }

      fun create(instance: CycleGraph, obj: Provider<Any>): Factory<Any> {
        return ProvideObjectWithCycleMetroFactory(instance = instance, obj = obj)
      }

      fun provideObjectWithCycle(instance: CycleGraph, obj: Provider<Any>): Any {
        return instance.provideObjectWithCycle(obj = obj)
      }

    }

    private constructor(instance: CycleGraph, obj: Provider<Any>) /* primary */ {
      super/*Any*/()
      /* <init>() */

    }

    override operator fun invoke(): Any {
      return Companion.provideObjectWithCycle(instance = <this>.#instance, obj = <this>.#obj)
    }

    fun mirrorFunction(obj: Provider<Any>): Any {
      return error(message = "Never called")
    }

  }

  abstract fun a(): A

  abstract fun c(): C

  abstract fun childCycleGraph(): Factory

  @Provides
  private final fun provideObjectWithCycle(obj: Provider<Any>): Any {
    return "object"
  }

  abstract val objWithCycle: Any
    abstract get

}

