class Base {
  constructor() /* primary */ {
    super/*Any*/()
    /* <init>() */

  }

}

@Inject
class ConsumerA {
  val consumer: Provider<SetConsumer>
    field = consumer
    get

  @Deprecated(message = "This synthesized declaration should not be used directly", level = DeprecationLevel.HIDDEN)
  class MetroFactory : Factory<ConsumerA> {
    private /* final field */ val consumer: Provider<SetConsumer> = consumer
    companion object Companion {
      private constructor() /* primary */ {
        super/*Any*/()
        /* <init>() */

      }

      fun create(consumer: Provider<SetConsumer>): Factory<ConsumerA> {
        return MetroFactory(consumer = consumer)
      }

      fun newInstance(consumer: Provider<SetConsumer>): ConsumerA {
        return ConsumerA(consumer = consumer)
      }

    }

    private constructor(consumer: Provider<SetConsumer>) /* primary */ {
      super/*Any*/()
      /* <init>() */

    }

    override operator fun invoke(): ConsumerA {
      return Companion.newInstance(consumer = <this>.#consumer)
    }

    fun mirrorFunction(consumer: Provider<SetConsumer>): ConsumerA {
      return error(message = "Never called")
    }

  }

  constructor(consumer: Provider<SetConsumer>) /* primary */ {
    super/*Any*/()
    /* <init>() */

  }

}

@Inject
class ConsumerB {
  val consumer: Provider<SetConsumer>
    field = consumer
    get

  @Deprecated(message = "This synthesized declaration should not be used directly", level = DeprecationLevel.HIDDEN)
  class MetroFactory : Factory<ConsumerB> {
    private /* final field */ val consumer: Provider<SetConsumer> = consumer
    companion object Companion {
      private constructor() /* primary */ {
        super/*Any*/()
        /* <init>() */

      }

      fun create(consumer: Provider<SetConsumer>): Factory<ConsumerB> {
        return MetroFactory(consumer = consumer)
      }

      fun newInstance(consumer: Provider<SetConsumer>): ConsumerB {
        return ConsumerB(consumer = consumer)
      }

    }

    private constructor(consumer: Provider<SetConsumer>) /* primary */ {
      super/*Any*/()
      /* <init>() */

    }

    override operator fun invoke(): ConsumerB {
      return Companion.newInstance(consumer = <this>.#consumer)
    }

    fun mirrorFunction(consumer: Provider<SetConsumer>): ConsumerB {
      return error(message = "Never called")
    }

  }

  constructor(consumer: Provider<SetConsumer>) /* primary */ {
    super/*Any*/()
    /* <init>() */

  }

}

@Inject
class Entry {
  val a: ConsumerA
    field = a
    get

  val b: ConsumerB
    field = b
    get

  @Deprecated(message = "This synthesized declaration should not be used directly", level = DeprecationLevel.HIDDEN)
  class MetroFactory : Factory<Entry> {
    private /* final field */ val a: Provider<ConsumerA> = a
    private /* final field */ val b: Provider<ConsumerB> = b
    companion object Companion {
      private constructor() /* primary */ {
        super/*Any*/()
        /* <init>() */

      }

      fun create(a: Provider<ConsumerA>, b: Provider<ConsumerB>): Factory<Entry> {
        return MetroFactory(a = a, b = b)
      }

      fun newInstance(a: ConsumerA, b: ConsumerB): Entry {
        return Entry(a = a, b = b)
      }

    }

    private constructor(a: Provider<ConsumerA>, b: Provider<ConsumerB>) /* primary */ {
      super/*Any*/()
      /* <init>() */

    }

    override operator fun invoke(): Entry {
      return Companion.newInstance(a = <this>.#a.invoke(), b = <this>.#b.invoke())
    }

    fun mirrorFunction(a: ConsumerA, b: ConsumerB): Entry {
      return error(message = "Never called")
    }

  }

  constructor(a: ConsumerA, b: ConsumerB) /* primary */ {
    super/*Any*/()
    /* <init>() */

  }

}

@Inject
class SetConsumer {
  val set: Set<Int>
    field = set
    get

  @Deprecated(message = "This synthesized declaration should not be used directly", level = DeprecationLevel.HIDDEN)
  class MetroFactory : Factory<SetConsumer> {
    private /* final field */ val set: Provider<Set<Int>> = set
    companion object Companion {
      private constructor() /* primary */ {
        super/*Any*/()
        /* <init>() */

      }

      fun create(set: Provider<Set<Int>>): Factory<SetConsumer> {
        return MetroFactory(set = set)
      }

      fun newInstance(set: Set<Int>): SetConsumer {
        return SetConsumer(set = set)
      }

    }

    private constructor(set: Provider<Set<Int>>) /* primary */ {
      super/*Any*/()
      /* <init>() */

    }

    override operator fun invoke(): SetConsumer {
      return Companion.newInstance(set = <this>.#set.invoke())
    }

    fun mirrorFunction(set: Set<Int>): SetConsumer {
      return error(message = "Never called")
    }

  }

  constructor(set: Set<Int>) /* primary */ {
    super/*Any*/()
    /* <init>() */

  }

}

@DependencyGraph
interface TestGraph {
  @Deprecated(message = "This synthesized declaration should not be used directly", level = DeprecationLevel.HIDDEN)
  @MetroImplMarker
  class Impl : TestGraph {
    private val thisGraphInstance: TestGraph
      field = <this>

    private val provideBaseProvider: Provider<Base>
      field = Companion.create(instance = <this>.#thisGraphInstance)

    private val setConsumerProvider: Provider<SetConsumer>
      field = Companion.create(set = <this>.<get-setOfInt>())

    private constructor() /* primary */ {
      super/*Any*/()
      /* <init>() */

    }

    override val entry: Entry
      override get(): Entry {
        return Entry(a = ConsumerA(consumer = <this>.#setConsumerProvider), b = ConsumerB(consumer = <this>.#setConsumerProvider))
      }

    private val setOfInt: Provider<Set<Int>>
      private get(): Provider<Set<Int>> {
        return Companion.builder<Int>(individualProviderSize = 2, collectionProviderSize = 0).addProvider(individualProvider = Companion.create(instance = <this>.#thisGraphInstance, base = <this>.#provideBaseProvider)).addProvider(individualProvider = Companion.create(instance = <this>.#thisGraphInstance, base = <this>.#provideBaseProvider)).build()
      }

  }

  companion object Companion {
    private constructor() /* primary */ {
      super/*Any*/()
      /* <init>() */

    }

    @GraphFactoryInvokeFunctionMarker
    operator fun invoke(): TestGraph {
      return Impl()
    }

  }

  @Deprecated(message = "This synthesized declaration should not be used directly", level = DeprecationLevel.HIDDEN)
  @CallableMetadata(callableName = "provideBase", propertyName = "", startOffset = 1163, endOffset = 1249, newInstanceName = "provideBase")
  class ProvideBaseMetroFactory : Factory<Base> {
    private /* final field */ val instance: TestGraph = instance
    companion object Companion {
      private constructor() /* primary */ {
        super/*Any*/()
        /* <init>() */

      }

      fun create(instance: TestGraph): Factory<Base> {
        return ProvideBaseMetroFactory(instance = instance)
      }

      fun provideBase(instance: TestGraph): Base {
        return instance.provideBase()
      }

    }

    private constructor(instance: TestGraph) /* primary */ {
      super/*Any*/()
      /* <init>() */

    }

    override operator fun invoke(): Base {
      return Companion.provideBase(instance = <this>.#instance)
    }

    fun mirrorFunction(): Base {
      return error(message = "Never called")
    }

  }

  @Deprecated(message = "This synthesized declaration should not be used directly", level = DeprecationLevel.HIDDEN)
  @CallableMetadata(callableName = "provideInt1", propertyName = "", startOffset = 1253, endOffset = 1308, newInstanceName = "provideInt1")
  class ProvideInt1MetroFactory : Factory<Int> {
    private /* final field */ val instance: TestGraph = instance
    private /* final field */ val base: Provider<Base> = base
    companion object Companion {
      private constructor() /* primary */ {
        super/*Any*/()
        /* <init>() */

      }

      fun create(instance: TestGraph, base: Provider<Base>): Factory<Int> {
        return ProvideInt1MetroFactory(instance = instance, base = base)
      }

      fun provideInt1(instance: TestGraph, base: Base): Int {
        return instance.provideInt1(base = base)
      }

    }

    private constructor(instance: TestGraph, base: Provider<Base>) /* primary */ {
      super/*Any*/()
      /* <init>() */

    }

    override operator fun invoke(): Int {
      return Companion.provideInt1(instance = <this>.#instance, base = <this>.#base.invoke())
    }

    @IntoSet
    fun mirrorFunction(base: Base): Int {
      return error(message = "Never called")
    }

  }

  @Deprecated(message = "This synthesized declaration should not be used directly", level = DeprecationLevel.HIDDEN)
  @CallableMetadata(callableName = "provideInt2", propertyName = "", startOffset = 1311, endOffset = 1366, newInstanceName = "provideInt2")
  class ProvideInt2MetroFactory : Factory<Int> {
    private /* final field */ val instance: TestGraph = instance
    private /* final field */ val base: Provider<Base> = base
    companion object Companion {
      private constructor() /* primary */ {
        super/*Any*/()
        /* <init>() */

      }

      fun create(instance: TestGraph, base: Provider<Base>): Factory<Int> {
        return ProvideInt2MetroFactory(instance = instance, base = base)
      }

      fun provideInt2(instance: TestGraph, base: Base): Int {
        return instance.provideInt2(base = base)
      }

    }

    private constructor(instance: TestGraph, base: Provider<Base>) /* primary */ {
      super/*Any*/()
      /* <init>() */

    }

    override operator fun invoke(): Int {
      return Companion.provideInt2(instance = <this>.#instance, base = <this>.#base.invoke())
    }

    @IntoSet
    fun mirrorFunction(base: Base): Int {
      return error(message = "Never called")
    }

  }

  @Provides
  private fun provideBase(): Base {
    return Base()
  }

  @Provides
  @IntoSet
  private fun provideInt1(base: Base): Int {
    return 1
  }

  @Provides
  @IntoSet
  private fun provideInt2(base: Base): Int {
    return 2
  }

  abstract val entry: Entry
    abstract get

}

